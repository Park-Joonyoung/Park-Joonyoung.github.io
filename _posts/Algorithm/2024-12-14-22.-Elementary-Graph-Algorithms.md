---
title: 22. Elementary Graph Algorithms
# description: Short summary of the post
date: 2024-12-14 16:52
categories: [Computer Science, Algorithm]
tags: [graph-algorithm, bfs, dfs]     # TAG names should always be lowercase
math: true
pin: false
---

## 22.1 Representations of graphs

We can choose between two standard ways to represent a graph $$ G = (V, \ E) $$: as a collection of adjacency lists or as an adjacency matrix.
Adjacency-list representation provides a compact way to represent sparse graphs $$ \left( |E| \ll |V|^2 \right) $$.
Adjacency-matrix representation is more preferred when the graph is dense $$ \left( |E| \approx |V|^2 \right) $$ or when we need to tell quickly if there is an edge connecting two given vertices.

The adjacency-list representation of a graph $$ G = (V, \ E) $$ consists of an array $$ Adj $$ of $$ |V| $$ lists, one for each vertex in $$ V $$.
For each $$ u \in V $$, the adjacency list $$ Adj[u] $$ contains all the vertices $$ v $$ such that there is an edge $$ (u, \ v) \in E $$.
If $$ G $$ is a directed graph, the sum of the lenghts of all the adjacency lists is $$ |E| $$.
If $$ G $$ is an undirected graph, the sum of the lenghts of all the adjacency lists is $$ 2|E| $$.
For both directed and undirected graphs, the adjacency-list representation requires $$ \Theta (V + E) $$ amount of memory.

Adjacency lists can represent weighted graphs, that is, graphs for which each edge has an associated weight, typically given by a weight function $$ w : E \rightarrow \mathbb{R} $$.
We can simply store the weight $$ w(u, \ v) $$ of the edge $$ (u, \ v) \in E $$ with vertex $$ v $$ in $$ u $$'s adjacency list.
A potential disadvantage of the adjacency-list representation is that it provides no quicker way to determine whether a given edge $$ (u, \ v) $$ is present in the graph than to search for $$ v $$ in the adjacency list $$ Adj[u] $$.

The adjacency-matrix representation of a graph $$ G $$ consists of a
$$ |V| \times |V| $$
matrix $$ A = (a_{ij}) $$ such that

$$
\begin{align*}
    a_{ij} = 
    \begin{cases}
        1 & \text{if } (i, \ j) \in E \\
        0 & \text{otherwise}
    \end{cases}
\end{align*}
$$

The adjacency-matrix of a graph requires $$ \Theta \left( V^2 \right) $$ memory, independent of the number of edges in the graph.
Since in an undirected graph, $$ (u, \ v) $$ and $$ (v, \ u) $$ represent the same edge, the adjacency matrix $$ A $$ of an undirected graph is its own transpose: $$ A = A^T $$.
Like adjacency lists, adjacency matrices can represent weighted graphs.
If $$ G = (V, \ E) $$ is a weighted graph with edge-weight function $$ w $$, we can simply store the weight $$ w(u, \ v) $$ of the edge $$ (u, \ v) \in E $$ as the entry in row $$ u $$ and column $$ v $$ of the adjacency matrix.

## 22.2 Breadth-first search

Breadth-first search is one of the simplest algorithms for searching a graph and the archetype for many important graph algorithms.
Given a graph $$ G = (V, \ E) $$ and a source vertex $$ s $$, breadth-first search explores the edges of $$ G $$ to discover every vertex that is reachable from $$ s $$.
It computes the distance (smallest number of edges) from $$ s $$ to each reachable vertex.
Breadth-first search expands the frontier between discovered and undiscovered vertices uniformly across the breadth of the frontier.
That is, the algorithm discovers all vertices at distance $$ k $$ from $$ s $$ before discovering any vertices at distance $$ k + 1 $$.
The algorithm works on both directed and undirected graphs.

To keep track of progress, breadth-first search colors each vertex white, gray, or black.
All vertices start out white and become gray and then black after they are discovered.
It also produces a breadth-first tree with root $$ s $$ that contains all reachable vertex.
Whenever the search discovers a white vertex $$ v $$ in the course of scanning the adjacency list of an already discovered vertex $$ u $$, the vertex $$ v $$ and the edge $$ (u, \ v) $$ are added to the tree.
We say that $$ u $$ is the predecessor or parent of $$ v $$ in the breadth-first tree.
For any vertex $$ v $$ reachable from $$ s $$, the simple path in the breadth-first tree from $$ s $$ to $$ v $$ corresponds to a shortest path (a path containing the smallest number of edges) from $$ s $$ to $$ v $$ in $$ G $$.

BFS($$ G, \ s $$)

>for each vertex $$ u \in G.V - \{ s \} $$  
>&nbsp;&nbsp;&nbsp;&nbsp;$$ u.color = $$ WHITE  
>&nbsp;&nbsp;&nbsp;&nbsp;$$ u.d = \infty $$  
>&nbsp;&nbsp;&nbsp;&nbsp;$$ u.\pi = $$ NIL  
>$$ s.color = $$ GRAY  
>$$ s.d = 0 $$  
>$$ Q = \emptyset $$  
>ENQUEUE($$ Q, \ s $$)  
>while $$ Q \neq \emptyset $$  
>&nbsp;&nbsp;&nbsp;&nbsp;$$ u = $$ DEQUEUE($$ Q $$)  
>&nbsp;&nbsp;&nbsp;&nbsp;for each $$ v \in G.Adj[u] $$  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if $$ v.color == $$ WHITE  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$$ v.color = $$ GRAY  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$$ v.d = u.d + 1 $$  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$$ v.\pi = u $$  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ENQUEUE($$ Q, \ v $$)  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$$u.color = $$ BLACK
