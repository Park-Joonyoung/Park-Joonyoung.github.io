---
title: 22. Elementary Graph Algorithms
# description: Short summary of the post
date: 2024-12-14 16:52
categories: [Computer Science, Algorithm]
tags: [graph-algorithm, bfs, dfs]     # TAG names should always be lowercase
math: true
pin: false
---

## 22.1 Representations of graphs

We can choose between two standard ways to represent a graph $$ G = (V, \ E) $$: as a collection of adjacency lists or as an adjacency matrix.
Adjacency-list representation provides a compact way to represent sparse graphs $$ \left( |E| \ll |V|^2 \right) $$.
Adjacency-matrix representation is more preferred when the graph is dense $$ \left( |E| \approx |V|^2 \right) $$ or when we need to tell quickly if there is an edge connecting two given vertices.

The adjacency-list representation of a graph $$ G = (V, \ E) $$ consists of an array $$ Adj $$ of $$ |V| $$ lists, one for each vertex in $$ V $$.
For each $$ u \in V $$, the adjacency list $$ Adj[u] $$ contains all the vertices $$ v $$ such that there is an edge $$ (u, \ v) \in E $$.
If $$ G $$ is a directed graph, the sum of the lenghts of all the adjacency lists is $$ |E| $$.
If $$ G $$ is an undirected graph, the sum of the lenghts of all the adjacency lists is $$ 2|E| $$.
For both directed and undirected graphs, the adjacency-list representation requires $$ \Theta (V + E) $$ amount of memory.

Adjacency lists can represent weighted graphs, that is, graphs for which each edge has an associated weight, typically given by a weight function $$ w : E \rightarrow \mathbb{R} $$.
We can simply store the weight $$ w(u, \ v) $$ of the edge $$ (u, \ v) \in E $$ with vertex $$ v $$ in $$ u $$'s adjacency list.
A potential disadvantage of the adjacency-list representation is that it provides no quicker way to determine whether a given edge $$ (u, \ v) $$ is present in the graph than to search for $$ v $$ in the adjacency list $$ Adj[u] $$.

The adjacency-matrix representation of a graph $$ G $$ consists of a
$$ |V| \times |V| $$
matrix $$ A = (a_{ij}) $$ such that

$$
\begin{align*}
    a_{ij} = 
    \begin{cases}
        1 & \text{if } (i, \ j) \in E \\
        0 & \text{otherwise}
    \end{cases}
\end{align*}
$$

The adjacency-matrix of a graph requires $$ \Theta \left( V^2 \right) $$ memory, independent of the number of edges in the graph.
Since in an undirected graph, $$ (u, \ v) $$ and $$ (v, \ u) $$ represent the same edge, the adjacency matrix $$ A $$ of an undirected graph is its own transpose: $$ A = A^T $$.
Like adjacency lists, adjacency matrices can represent weighted graphs.
If $$ G = (V, \ E) $$ is a weighted graph with edge-weight function $$ w $$, we can simply store the weight $$ w(u, \ v) $$ of the edge $$ (u, \ v) \in E $$ as the entry in row $$ u $$ and column $$ v $$ of the adjacency matrix.

## 22.2 Breadth-first search

Breadth-first search is one of the simplest algorithms for searching a graph and the archetype for many important graph algorithms.
Given a graph $$ G = (V, \ E) $$ and a source vertex $$ s $$, breadth-first search explores the edges of $$ G $$ to discover every vertex that is reachable from $$ s $$.
It computes the distance (smallest number of edges) from $$ s $$ to each reachable vertex.
Breadth-first search expands the frontier between discovered and undiscovered vertices uniformly across the breadth of the frontier.
That is, the algorithm discovers all vertices at distance $$ k $$ from $$ s $$ before discovering any vertices at distance $$ k + 1 $$.
The algorithm works on both directed and undirected graphs.

To keep track of progress, breadth-first search colors each vertex white, gray, or black.
All vertices start out white and become gray and then black after they are discovered.
It also produces a breadth-first tree with root $$ s $$ that contains all reachable vertex.
Whenever the search discovers a white vertex $$ v $$ in the course of scanning the adjacency list of an already discovered vertex $$ u $$, the vertex $$ v $$ and the edge $$ (u, \ v) $$ are added to the tree.
We say that $$ u $$ is the predecessor or parent of $$ v $$ in the breadth-first tree.
For any vertex $$ v $$ reachable from $$ s $$, the simple path in the breadth-first tree from $$ s $$ to $$ v $$ corresponds to a shortest path (a path containing the smallest number of edges) from $$ s $$ to $$ v $$ in $$ G $$.

BFS($$ G, \ s $$)

>&nbsp;1&nbsp; for each vertex $$ u \in G.V - \{ s \} $$  
>&nbsp;2&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;$$ u.color = $$ WHITE  
>&nbsp;3&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;$$ u.d = \infty $$  
>&nbsp;4&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;$$ u.\pi = $$ NIL  
>&nbsp;5&nbsp; $$ s.color = $$ GRAY  
>&nbsp;6&nbsp; $$ s.d = 0 $$  
>&nbsp;7&nbsp; $$ Q = \emptyset $$  
>&nbsp;8&nbsp; ENQUEUE($$ Q, \ s $$)  
>&nbsp;9&nbsp; while $$ Q \neq \emptyset $$  
>10&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;$$ u = $$ DEQUEUE($$ Q $$)  
>11&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;for each $$ v \in G.Adj[u] $$  
>12&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if $$ v.color == $$ WHITE  
>13&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$$ v.color = $$ GRAY  
>14&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$$ v.d = u.d + 1 $$  
>15&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$$ v.\pi = u $$  
>16&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ENQUEUE($$ Q, \ v $$)  
>17&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$$u.color = $$ BLACK

The procedure BFS works as follows.
Lines 1–4 paint every vertex white, set $$ u.d $$ to be infinity for each vertex $$ u $$, and set the parent of every vertex to be NIL except the source vertex $$ s $$.
Lines 5–7 paint $$ s $$ gray, initialize $$ s.d $$ as $$ 0 $$, set the predecessor of the source to be NIL.
Lines 8–9 initilize $$ Q $$ to the queue containing just the vertex $$ s $$.

The while loop of lines 10–18 iterates as long as there remain gray vertices, which are discovered vertices that have not yet had their adjacency lists fully examined.
This while loop maintains the following invariant:

>At the test in line 10, the queue $$ Q $$ consists of the set of gray vertices.

Prior to the first iteration, the only gray vertex, and the only vertex in $$ Q $$, is the source vertex $$ s $$.
Line 11 determines the gray vertex $$ u $$ at the head of the queue $$ Q $$ and removes it from $$ Q $$.
The for loop of lines 12–17 considers each vertex $$ v $$ in the adjacency list of $$ u $$.
If $$ v $$ is white, then it has not yet been discovered, and the procedure discovers it by executing lines 14–17.
The procedure paints vertex $$ v $$ gray, sets its distance $$ v.d $$ to $$ u.d + 1 $$, records $$ u $$ as its parent $$ v.\pi $$, and places it at the tail of the queue $$ Q $$.
Once the procedure has examined all the vertices on $$ u $$'s adjacency list, it blackens $$ u $$ in line 18.

The results of breadth-first search depend upon the order in which the neighbors of a given vertex are visited in line 12.
The breadth-first tree may vary, but the distances $$ d $$ computed by the algorithm will not.

### Analysis

By using aggregate analysis, the total running time of the breadth-first search algorithm can be calculated.
The test in line 13 ensures that each vertex is enqueued at most once, and hence dequeued at most once.
The operations of enqueuing and dequeuing take $$ O(1) $$ time, so the total time devoted to queue operations is $$ O(V) $$.
Because the procedure scans the adjacency list of each vertex only when the vertex is dequeued, it scans each adjacency list at most once.
Since the sum of the lengths of all the adjacency lists is $$ \Theta(E) $$, the total time spent in scanning adjacency lists is $$ O(E) $$.
The overhead for initialization is $$ O(V) $$, and thus the total running time of the BFS procedure is $$ O(V + E) $$.

### Shortest paths

Define the shortest-path distance $$ \delta(s, \ v) $$ from $$ s $$ to $$ v $$ as the minimum number of edges in any path from vertex $$ s $$ to vertex $$ v $$.
If there is no path from $$ s $$ to $$ v $$, then $$ \delta(s, \ v) = \infty $$.

### Lemma 22.1

Let $$ G = (V, \ E) $$ be a directed or undirected graph, and let $$ s \in V $$ be an arbitrary vertex.
Then, for any edge $$ (u, \ v) \in E $$, $$ \delta(s, \ v) \le \delta(s, \ u) + 1 $$.

**Proof**  
If $$ u $$ is reachable from $$ s $$, then so is $$ v $$.
In this case, the shortest path from $$ s $$ to $$ v $$ cannot be longer than the shortest path from $$ s $$ to $$ u $$ followed by the edge $$ (u, \ v) $$.
If $$ u $$ is not reachable from $$ s $$, then $$ \delta(s, \ u) = \infty $$. $$ \blacksquare $$

### Lemma 22.2

Let $$ G = (V, \ E) $$ be a directed or undirected graph, and suppose that BFS is run on $$ G $$ from a given source vertex $$ s \in V $$.
Then upon termination, for each vertex $$ v \in V $$, $$ v.d \ge \delta(s, \ v) $$.

**Proof**  
We use induction on the number of ENQUEUE operation.
The inductive hypothesis is that $$ v.d \ge \delta(s, \ v) $$ for all $$ v \in V $$.
When $$ s $$ is enqueued in $$ Q $$ in line 9, the inductive hypothesis holds since $$ s.d = 0 = \delta(s, \ s) $$ and $$ v.d = \infty \ge \delta(s, \ v) $$ for all $$ v \in V - \{ s \} $$.  
For the inductive step, consider a white vertex $$ v $$ that is discovered during the search from a vertex $$ u $$.
The inductive hypothesis implies that $$ u.d \ge \delta(s, \ u) $$.
From line 15 and Lemma 22.1, we obtain

$$
\begin{align*}
    v.d = u.d + 1 \ge \delta(s, \ u) + 1 \ge \delta(s, \ v)
\end{align*}
$$

Vertex $$ v $$ is once enqueued in line 17 and never enqueued again; the value of $$ v.d $$ does not change after it is determined.
Therefore, the inductive hypothesis is maintained. $$ \blacksquare $$

### Lemma 22.3

Suppose that during the execution of BFS on a graph $$ G = (V, \ E) $$, the queue $$ Q $$ contains the vertices $$\text{<} v_1, \ v_2, \dots, \ v_r \text{>} $$, where $$ v_1 $$ is the head of $$ Q $$ and $$ v_r $$ is the tail.
Then, $$ v_{r}.d \le v_{1}.d + 1  $$ and $$ v_{i}.d \le v_{i + 1}.d $$ for $$ i = 1, \ 2, \dots , r - 1 $$.

**Proof**  
The proof is by induction on the number of queue operations.
Initially, when the queue contains only $$ s $$, the lemma holds.  
For the inductive step, we must prove that the lemma holds after both dequeuing and enqueuing a vertex.
If the head $$ v_1 $$ of the queue is dequeued, $$ v_2 $$ becomes the new head.
(If the queue becomes empty, then the lemma holds vacuously.)
By the inductive hypothesis, $$ v_{1}.d \le v_{2}.d $$, but then we have $$ v_{r}.d \le v_{1}.d + 1 \le v_{2}.d + 1 $$.
Thus, the remaining inequalities are unaffected.  
When a vertex $$ v $$ is enqueued in line 17, it becomes $$ v_{r + 1} $$.
At that time, we have already removed vertex $$ u $$, whose adjacency list is currently being scanned, from the queue $$ Q $$.
By the inductive hypothesis, the new head $$ v_1 $$ has $$ v_{1}.d \ge u.d $$.
Thus, $$ v_{r + 1}.d = v.d = u.d + 1 \le v_{1}.d + 1 $$.
From the inductive hypothesis, we also have $$ v_{r}.d \le u.d + 1 $$, and so $$ v_{r}.d \le u.d + 1 = v.d = v_{r + 1}.d $$, and the remaining inequalities are unaffected.
Therefore, the lemma follows when $$ v $$ is enqueued. $$ \blacksquare $$

### Corollary 22.4

Suppose that vertices $$ v_i $$ and $$ v_j $$ are enqueued during the execution of BFS, and that $$ v_i $$ is enqueued before $$ v_j $$. Then $$ v_{i}.d \le v_{j}.d $$ at the time that $$ v_j $$ is enqueued.

**Proof**  
Immediate from Lemma 22.3 and the property that each vertex receives a finite $$ d $$ value at most once during the course of BFS. $$ \blacksquare $$

### Theorem 22.5 (Correctness of breadth-first search)

Let $$ G = (V, \ E) $$ be a directed or undirected graph, and suppose that BFS is run on $$ G $$ from a given source vertex $$ s \in V $$.
Then, during its execution, BFS discovers every vertex $$ v \in V $$ that is reachable from the source $$ s $$, and upon termination, $$ v.d = \delta(s, \ v) $$ for all $$ v \in V $$.
Moreover, for any vertex $$ v \neq s $$ that is reachable from $$ s $$, one of the shortest paths from $$ s $$ to $$ v $$ is a shortest path from $$ s $$ to $$ v.\pi $$ followed by the edge $$ (v.\pi, \ v) $$.

**Proof**  
Assume that some vertex receives a $$ d $$ value not equal to its shortest-path distance.
Let $$ v $$ be the vertex with minimum $$ \delta(s, \ v) $$ that receives such an incorrect $$ d $$ value.
Clearly, $$ v \neq s $$.
By Lemma 22.2, $$ v.d \ge \delta(s, \ v) $$.
Vertex $$ v $$ must be reachable from $$ s $$, for if is not, then $$ \delta(s, \ v) = \infty \ge v.d $$.  
Let $$ u $$ be the vertex immediately preceding $$ v $$ on a shortest path from $$ s $$ to $$ v $$, so that $$ \delta(s, \ v) = \delta(s, \ u) + 1 $$.
Because $$ \delta(s, \ u) < \delta(s, \ v) $$, and because of how we chose $$ v $$, we have $$ u.d = \delta(s, \ u) $$.
Putting these properties together, we have

$$
\begin{align*}
    v.d > \delta(s, \ v) = \delta(s, \ u) + 1 = u.d + 1
\end{align*}
\label{eq:1}
\tag{22.1}
$$

Now consider the time when BFS chooses to dequeue vertex $$ u $$ from $$ Q $$ in line 11.
At this time, vertex $$ v $$ is either white, gray, or black.
In each of these cases, we derive a contradiction to inequality \eqref{eq:1}.  
If $$ v $$ is white, then line 15 sets $$ v.d = u.d + 1 $$, contradicting \eqref{eq:1}.  
If $$ v $$ is black, then it was already removed from the queue and, by Corollary 22.4, we have $$ v.d \le u.d $$, again contradicting \eqref{eq:1}.  
If $$ v $$ is gray, then it was painted gray upon dequeuing some vertex $$ w $$, which was removed from $$ Q $$ earlier than $$ u $$ and for which $$ v.d = w.d + 1 $$.
By Corollary 22.4, however, $$ w.d \le u.d $$, and so we have $$ v.d = w.d + 1 \le u.d + 1 $$, once again contradicting \eqref{eq:1}.  
Thus we conclude that $$ v.d = \delta(s, \ v) $$ for all $$ v \in V $$.
All vertices $$ v $$ reachable from $$ s $$ must be discovered, for otherwise they would have $$ \infty = v.d > \delta(s, \ v) $$.
Observe that if $$ v.\pi = u $$, then $$ v.d = u.d + 1 $$.
Therefore, we can obtain a shortest path from $$ s $$ to $$ v $$ by taking a shortest path from $$ s $$ to $$ v.\pi $$ and then traversing the edge $$ (v.\pi, \ v) $$. $$ \blacksquare $$