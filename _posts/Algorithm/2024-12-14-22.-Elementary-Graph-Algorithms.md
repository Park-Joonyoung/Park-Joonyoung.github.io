---
title: 22. Elementary Graph Algorithms
# description: Short summary of the post
date: 2024-12-14 16:52
categories: [Computer Science, Algorithm]
tags: [graph-algorithm, bfs, dfs]     # TAG names should always be lowercase
math: true
pin: false
---

## 22.1 Representations of graphs

We can choose between two standard ways to represent a graph $$ G = (V, \ E) $$: as a collection of adjacency lists or as an adjacency matrix.
Adjacency-list representation provides a compact way to represent sparse graphs $$ \left( |E| \ll |V|^2 \right) $$.
Adjacency-matrix representation is more preferred when the graph is dense $$ \left( |E| \approx |V|^2 \right) $$ or when we need to tell quickly if there is an edge connecting two given vertices.

The adjacency-list representation of a graph $$ G = (V, \ E) $$ consists of an array $$ Adj $$ of $$ |V| $$ lists, one for each vertex in $$ V $$.
For each $$ u \in V $$, the adjacency list $$ Adj[u] $$ contains all the vertices $$ v $$ such that there is an edge $$ (u, \ v) \in E $$.
If $$ G $$ is a directed graph, the sum of the lenghts of all the adjacency lists is $$ |E| $$.
If $$ G $$ is an undirected graph, the sum of the lenghts of all the adjacency lists is $$ 2|E| $$.
For both directed and undirected graphs, the adjacency-list representation requires $$ \Theta (V + E) $$ amount of memory.

Adjacency lists can represent weighted graphs, that is, graphs for which each edge has an associated weight, typically given by a weight function $$ w : E \rightarrow \mathbb{R} $$.
We can simply store the weight $$ w(u, \ v) $$ of the edge $$ (u, \ v) \in E $$ with vertex $$ v $$ in $$ u $$'s adjacency list.
A potential disadvantage of the adjacency-list representation is that it provides no quicker way to determine whether a given edge $$ (u, \ v) $$ is present in the graph than to search for $$ v $$ in the adjacency list $$ Adj[u] $$.

The adjacency-matrix representation of a graph $$ G $$ consists of a
$$ |V| \times |V| $$
matrix $$ A = (a_{ij}) $$ such that

$$
\begin{align*}
    a_{ij} = 
    \begin{cases}
        1 & \text{if } (i, \ j) \in E \\
        0 & \text{otherwise}
    \end{cases}
\end{align*}
$$

The adjacency-matrix of a graph requires $$ \Theta \left( V^2 \right) $$ memory, independent of the number of edges in the graph.
Since in an undirected graph, $$ (u, \ v) $$ and $$ (v, \ u) $$ represent the same edge, the adjacency matrix $$ A $$ of an undirected graph is its own transpose: $$ A = A^T $$.
Like adjacency lists, adjacency matrices can represent weighted graphs.
If $$ G = (V, \ E) $$ is a weighted graph with edge-weight function $$ w $$, we can simply store the weight $$ w(u, \ v) $$ of the edge $$ (u, \ v) \in E $$ as the entry in row $$ u $$ and column $$ v $$ of the adjacency matrix.

## 22.2 Breadth-first search

Breadth-first search is one of the simplest algorithms for searching a graph and the archetype for many important graph algorithms.
Given a graph $$ G = (V, \ E) $$ and a source vertex $$ s $$, breadth-first search explores the edges of $$ G $$ to discover every vertex that is reachable from $$ s $$.
It computes the distance (smallest number of edges) from $$ s $$ to each reachable vertex.
Breadth-first search expands the frontier between discovered and undiscovered vertices uniformly across the breadth of the frontier.
That is, the algorithm discovers all vertices at distance $$ k $$ from $$ s $$ before discovering any vertices at distance $$ k + 1 $$.
The algorithm works on both directed and undirected graphs.

To keep track of progress, breadth-first search colors each vertex white, gray, or black.
All vertices start out white and become gray and then black after they are discovered.
It also produces a breadth-first tree with root $$ s $$ that contains all reachable vertex.
Whenever the search discovers a white vertex $$ v $$ in the course of scanning the adjacency list of an already discovered vertex $$ u $$, the vertex $$ v $$ and the edge $$ (u, \ v) $$ are added to the tree.
We say that $$ u $$ is the predecessor or parent of $$ v $$ in the breadth-first tree.
For any vertex $$ v $$ reachable from $$ s $$, the simple path in the breadth-first tree from $$ s $$ to $$ v $$ corresponds to a shortest path (a path containing the smallest number of edges) from $$ s $$ to $$ v $$ in $$ G $$.

BFS($$ G, \ s $$)

>&nbsp;1&nbsp; for each vertex $$ u \in G.V - \{ s \} $$  
>&nbsp;2&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;$$ u.color = $$ WHITE  
>&nbsp;3&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;$$ u.d = \infty $$  
>&nbsp;4&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;$$ u.\pi = $$ NIL  
>&nbsp;5&nbsp; $$ s.color = $$ GRAY  
>&nbsp;6&nbsp; $$ s.d = 0 $$  
>&nbsp;7&nbsp; $$ Q = \emptyset $$  
>&nbsp;8&nbsp; ENQUEUE($$ Q, \ s $$)  
>&nbsp;9&nbsp; while $$ Q \neq \emptyset $$  
>10&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;$$ u = $$ DEQUEUE($$ Q $$)  
>11&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;for each $$ v \in G.Adj[u] $$  
>12&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if $$ v.color == $$ WHITE  
>13&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$$ v.color = $$ GRAY  
>14&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$$ v.d = u.d + 1 $$  
>15&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$$ v.\pi = u $$  
>16&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ENQUEUE($$ Q, \ v $$)  
>17&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$$u.color = $$ BLACK

The procedure BFS works as follows.
Lines 1–4 paint every vertex white, set $$ u.d $$ to be infinity for each vertex $$ u $$, and set the parent of every vertex to be NIL except the source vertex $$ s $$.
Lines 5–7 paint $$ s $$ gray, initialize $$ s.d $$ as $$ 0 $$, set the predecessor of the source to be NIL.
Lines 8–9 initilize $$ Q $$ to the queue containing just the vertex $$ s $$.

The while loop of lines 10–18 iterates as long as there remain gray vertices, which are discovered vertices that have not yet had their adjacency lists fully examined.
This while loop maintains the following invariant:

>At the test in line 10, the queue $$ Q $$ consists of the set of gray vertices.

Prior to the first iteration, the only gray vertex, and the only vertex in $$ Q $$, is the source vertex $$ s $$.
Line 11 determines the gray vertex $$ u $$ at the head of the queue $$ Q $$ and removes it from $$ Q $$.
The for loop of lines 12–17 considers each vertex $$ v $$ in the adjacency list of $$ u $$.
If $$ v $$ is white, then it has not yet been discovered, and the procedure discovers it by executing lines 14–17.
The procedure paints vertex $$ v $$ gray, sets its distance $$ v.d $$ to $$ u.d + 1 $$, records $$ u $$ as its parent $$ v.\pi $$, and places it at the tail of the queue $$ Q $$.
Once the procedure has examined all the vertices on $$ u $$'s adjacency list, it blackens $$ u $$ in line 18.

The results of breadth-first search depend upon the order in which the neighbors of a given vertex are visited in line 12.
The breadth-first tree may vary, but the distances $$ d $$ computed by the algorithm will not.

### Analysis

By using aggregate analysis, the total running time of the breadth-first search algorithm can be calculated.
The test in line 13 ensures that each vertex is enqueued at most once, and hence dequeued at most once.
The operations of enqueuing and dequeuing take $$ O(1) $$ time, so the total time devoted to queue operations is $$ O(V) $$.
Because the procedure scans the adjacency list of each vertex only when the vertex is dequeued, it scans each adjacency list at most once.
Since the sum of the lengths of all the adjacency lists is $$ \Theta(E) $$, the total time spent in scanning adjacency lists is $$ O(E) $$.
The overhead for initialization is $$ O(V) $$, and thus the total running time of the BFS procedure is $$ O(V + E) $$.

### Shortest paths

Define the shortest-path distance $$ \delta(s, \ v) $$ from $$ s $$ to $$ v $$ as the minimum number of edges in any path from vertex $$ s $$ to vertex $$ v $$.
If there is no path from $$ s $$ to $$ v $$, then $$ \delta(s, \ v) = \infty $$.

#### Lemma 22.1